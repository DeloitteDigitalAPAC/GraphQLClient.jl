var documenterSearchIndex = {"docs":
[{"location":"struct_types_usage/#using_struct_types","page":"Struct Types Usage","title":"Struct Types Usage","text":"","category":"section"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"JSON is the most common serialization format for GraphQL servers, and GraphQLClient assumes a JSON response. As explained in Custom Types, GraphQLClient deserialises this response by doing JSON3.read(response, GQLResponse{T}) where T defaults to Any but can be configured by using the output_type positional argument. The main benefit of configuring this is to provide type stability to functions that use the response.","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"Typically, fields in a response will have different types and therefore a struct rather than a Dict is better for type stability as structs can have fields of different types, where as values of a dictionary are either of the same type or of an abstract type.","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"To deserialise the response into structs, define a type that matches the expected output and set its StructType. This enables JSON3 to deserialise directly into that type.","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"Because the GraphQL specification requires that fields of the response are in the same order as fields in the operation, we know the order of fields in the response and can therefore use the StructType of OrderedStruct, which is very efficient (although note this doesn't check the field names, it simply deserialises each field in order). See the JSON3 documentation for more information about the StructTypes that can be used, along with other serialisation and deserialisation tricks.","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"For example","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"DocTestSetup = quote\n    using JSON3, StructTypes\n    using GraphQLClient: GQLResponse\n    using GraphQLClient\nend","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"julia> response_str = \"{\\\"data\\\":{\\\"MyQuery\\\":{\\\"field1\\\":1,\\\"field2\\\":2}}}\";\n\njulia> print(GraphQLClient.prettify_query(response_str))\n{\n    \"data\":{\n        \"MyQuery\":{\n            \"field1\":1\n            \"field2\":2\n        }\n    }\n}\n\njulia> struct MyQuery\n           field1::Int\n           field2::Int\n       end\n\njulia> StructTypes.StructType(::Type{MyQuery}) = StructTypes.OrderedStruct()\n\njulia> JSON3.read(response_str, GQLResponse{MyQuery})\nGQLResponse{MyQuery}\n  data: Dict{String, Union{Nothing, MyQuery}}\n          MyQuery: MyQuery","category":"page"},{"location":"struct_types_usage/#Handling-NULL-fields","page":"Struct Types Usage","title":"Handling NULL fields","text":"","category":"section"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"The fields of GraphQL responses are often nullable, i.e. they can be nothing. If this occurred in the above example, then deserialisation would fail as it attempts to read null as an integer.","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"julia> response_str = \"{\\\"data\\\":{\\\"MyQuery\\\":{\\\"field1\\\":1,\\\"field2\\\":null}}}\";\n\njulia> print(GraphQLClient.prettify_query(response_str))\n{\n    \"data\":{\n        \"MyQuery\":{\n            \"field1\":1\n            \"field2\":null\n        }\n    }\n}\n\njulia> JSON3.read(response_str, GQLResponse{MyQuery})\nERROR: ArgumentError: invalid JSON at byte position 63 while parsing type Int64: InvalidChar\n  ry\":{\"field1\":1,\"field2\":null}}}","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"In cases where this is due to an error from the server, then GraphQLClient will attempt to deserialise with Any to read the errors (see Response - Errors for further details), but when this is not due to an error we ideally want to be able to handle it without throwing an exception.","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"To do this we can make field types a Union without a significant affect on performance - it is slightly slower, but compared to the cost of performing an HTTP request this difference is usually neglible.","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"julia> struct MyQueryNullable\n           field1::Union{Nothing, Int}\n           field2::Union{Nothing, Int}\n       end\n\njulia> StructTypes.StructType(::Type{MyQueryNullable}) = StructTypes.OrderedStruct()\n\njulia> JSON3.read(response_str, GQLResponse{MyQueryNullable})\nGQLResponse{MyQueryNullable}\n  data: Dict{String, Union{Nothing, MyQueryNullable}}\n          MyQuery: MyQueryNullable","category":"page"},{"location":"struct_types_usage/","page":"Struct Types Usage","title":"Struct Types Usage","text":"DocTestSetup = nothing\nend","category":"page"},{"location":"client/#Client","page":"Client","title":"Client","text":"","category":"section"},{"location":"client/#Connecting-to-a-Server","page":"Client","title":"Connecting to a Server","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"A client can be instantiated by using the Client object","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"client = Client(\"https://countries.trevorblades.com\")","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"If only the endpoint is suppplied, the ws_endpoint (used for subscriptions) is assumed to be the same with \"http\" replaced by \"ws\".","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"Headers can be passed in a dictionary to the headers keyword argument, enabling things like authorisation tokens. These headers are  used directly in the HTTP requests to the server.","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"client = Client(\n    \"https://myurl.com/queries\",\n    \"wss://myurl.com/subscriptions\",\n    headers = Dict(\"Authorization\" => \"Bearer XXX\"),\n)","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"By default, when instantiated GraphQLClient will introspect the schema of the server and populate several fields of the Client object.","category":"page"},{"location":"client/#Global-Client","page":"Client","title":"Global Client","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"A client can be set as the global client, which means that queries and other operations do not need the client passing as an argument.","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"global_graphql_client(Client(\"https://countries.trevorblades.com\"))","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"The global client can then be accessed by the same function","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"julia> global_graphql_client()\nGraphQLClient Client\n       endpoint: https://countries.trevorblades.com\n    ws_endpoint: wss://countries.trevorblades.com","category":"page"},{"location":"client/#Introspection","page":"Client","title":"Introspection","text":"","category":"section"},{"location":"client/#What-needs-introspection?","page":"Client","title":"What needs introspection?","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"The following functionality requires introspection, and will attempt to introspect the client if it has not already been done so","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"Functions to view operations (see below)\nquery, mutate and open_subscription\ncheck that the operation exists\nuse schema to build variables strings for arguments\nquery - build output_fields if none supplied to function\nType Introspection","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"The following functionality does not need introspection","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"GraphQLClient.execute","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"Introspection is an incredibly powerful feature of GraphQL, and we hope to add more functions that make use of the informaton available in the schema.","category":"page"},{"location":"client/#Viewing-Operations","page":"Client","title":"Viewing Operations","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"The queries, mutations and subscriptions available from a server can be accessed by the following functions, which will all attempt to introspect the server if it has not already been completed.","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"get_queries(client)\nget_mutations(client)\nget_subscriptions(client)","category":"page"},{"location":"client/#Client-Fields","page":"Client","title":"Client Fields","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"There are several fields of Client that contain information relating to the schema. Whilst part of the private interface and therefore changes may occur outside of semantic versioning (in particular the format of this information may be changed to be more concretely typed), it can be accessed. If you have the need to ensure that this information can be accessed as part of the public interface, and therefore subject to semantic versioning, please open an issue.","category":"page"},{"location":"private/#Private","page":"Private","title":"Private","text":"","category":"section"},{"location":"private/","page":"Private","title":"Private","text":"Pages = [\"private.md\"]","category":"page"},{"location":"private/","page":"Private","title":"Private","text":"Package internals documentation.","category":"page"},{"location":"private/#Client","page":"Private","title":"Client","text":"","category":"section"},{"location":"private/","page":"Private","title":"Private","text":"Modules = [GraphQLClient]\nPages = [\"client.jl\", \"introspection.jl\"]\nPublic = false","category":"page"},{"location":"private/#GraphQLClient.CLIENT","page":"Private","title":"GraphQLClient.CLIENT","text":"CLIENT\n\nRef which contains the global Client.\n\n\n\n\n\n","category":"constant"},{"location":"private/#GraphQLClient._recursive_get_value-Tuple{Any, Any}","page":"Private","title":"GraphQLClient._recursive_get_value","text":"_recursive_get_value(dict, key)\n\nRecursively iterate through a dict until value of key is nothing.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.introspect_node-Tuple{Client, Any}","page":"Private","title":"GraphQLClient.introspect_node","text":"introspect_node(node)\n\nIntrospect single node in GQL schema.\n\n\n\n\n\n","category":"method"},{"location":"private/#Operations","page":"Private","title":"Operations","text":"","category":"section"},{"location":"private/","page":"Private","title":"Private","text":"Modules = [GraphQLClient]\nPages   = [\"queries.jl\", \"mutations.jl\", \"subscriptions.jl\", \"http_execution.jl\", \"gqlresponse.jl\", \"types.jl\"]\nFilter = t -> !in(t, (GraphQLClient.execute, GraphQLClient.GQLResponse))\nPublic = false","category":"page"},{"location":"private/#GraphQLClient.generic_gql_query-Union{Tuple{T}, Tuple{Client, String, Union{AbstractString, Alias}, Dict}, Tuple{Client, String, Union{AbstractString, Alias}, Dict, String}, Tuple{Client, String, Union{AbstractString, Alias}, Dict, String, Type{T}}} where T","page":"Private","title":"GraphQLClient.generic_gql_query","text":"generic_gql_query(client::Client,\n                  query_type::String,\n                  query_name::Union{Alias, String},\n                  query_args::Dict,\n                  output_str::String=\"\";\n                  direct_write=false,\n                  retries=1,\n                  retry_non_idempotent=true)\n\nBuild and execute a query to client.\n\nArguments\n\nclient::Client: GraphQL client.\nquery_type::String,: typically \"query\", \"mutation\" or \"subscription\".\nquery_name::Union{Alias, AbstractString}: name of query.\nquery_args::Dict: dictionary of argument key value pairs - can be nested with dictionaries and lists.\noutput_str::String: output string to be appended to query.\ndirect_write=false: if true, the query is formed by generating a string   from query_args directly, and the introspected schema is not used. Any ENUMs   must be wrapped in a GQLEnum. See directly_write_query_args for   more information.\noutput_type::Type=Any: output data type for query response object.\nretries=1: number of times the mutation will be attempted before erroring.\nreadtimeout=0: HTTP request timeout length. Set to 0 for no timeout.\nthrow_on_execution_error=false: set to true to throw an exception if the GraphQL server   response contains errors that occurred during execution.\nverbose=0: set to 1, 2 for extra logging.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.get_generic_query_payload","page":"Private","title":"GraphQLClient.get_generic_query_payload","text":"get_generic_query_payload(client::Client, query_type, query_name, query_args, output_str=\"\")\n\nGet the payload for a gql query.\n\nArguments\n\nquery_type: typically \"query\", \"mutation\" or \"subscription\".\nquery_name: name of query.\nquery_args: dictionary of argument key value pairs - can be nested with   dictionaries and lists.\noutput_str: output string to be appended to query.\nverbose=0: set to 1, 2 for extra logging.\n\n\n\n\n\n","category":"function"},{"location":"private/#GraphQLClient.get_generic_query_payload_direct_write","page":"Private","title":"GraphQLClient.get_generic_query_payload_direct_write","text":"get_generic_query_payload_direct_write(query_type, query_name, query_args, output_str=\"\")\n\nGet the payload for a gql query, with the main body of the query being JSON3.write(query_args).\n\nArguments\n\nquery_type: typically \"query\", \"mutation\" or \"subscription\".\nquery_name: name of query.\nquery_args: dictionary of argument key value pairs - can be nested with   dictionaries and lists.\noutput_str: output string to be appended to query.\nverbose=0: set to 1, 2 for extra logging.\n\n\n\n\n\n","category":"function"},{"location":"private/#GraphQLClient.clear_subscriptions-Tuple{}","page":"Private","title":"GraphQLClient.clear_subscriptions","text":"clear_subscriptions()\n\nRemoves all subscriptions from the subscription_tracker, throwing an error if any are still open.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.readfromwebsocket-Tuple{IO, Any, Any}","page":"Private","title":"GraphQLClient.readfromwebsocket","text":"readfromwebsocket(ws::IO, stopfn, subtimeout)\n\nRead from the websocket with the following logic:\n\nIf stopfn is nothing and subtimeout is 0, use readavailable   which blocks data is written to the stream.\nIf stopfn is not nothing, check the value of stopfn periodically.   If it returns true, the websocket is closed. The period is set to    subtimeout if greater than 0, otherwise 2 seconds is used.\nIf stopfn is nothing but subtimeout > 0, stop listening after   subtimeout seconds if no data has been received.\n\nA channel is returned with the data. If stopfn stops the websocket, the data will be :stopfn. If the timeout stops the websocket, the data will be :timeout\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient._execute-Union{Tuple{T}, Tuple{AbstractString, AbstractString, AbstractDict}, Tuple{AbstractString, AbstractString, AbstractDict, Type{T}}} where T","page":"Private","title":"GraphQLClient._execute","text":"_execute(endpoint::AbstractString,\n         execution_string::AbstractString,\n         headers::AbstractDict,\n         output_type::Type{T}=Any;\n         retries=1,\n         readtimeout=0,\n         throw_on_execution_error=false)::GQLResponse{T} where T\n\nPrivate function to execute a HTTP Post request.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.checkbodyforerrors-Tuple{GraphQLClient.GQLResponse}","page":"Private","title":"GraphQLClient.checkbodyforerrors","text":"checkbodyforerrors(body::GQLResponse)\n\nIf body has any errors, throw a GraphQLError.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.handle_deserialisation_error-Tuple{Exception, Any, Any}","page":"Private","title":"GraphQLClient.handle_deserialisation_error","text":"handle_deserialisation_error(::Exception, _, _)\nhandle_deserialisation_error(err::HTTP.StatusError, resp, output_type)\n\nHandle the error caught during deserialisation.\n\nIf it is an ArgumentError containing \"invalid JSON\" in its message, then we attempt to deserialise the body of the response using a GQLResponse{Any} object (if this wasn't the original output type). This is because this type can handle null fields in the response, whereas a user defined type may not.\n\nOnce deserialised, if there are errors in the body these are thrown. Otherwise, the original error is rethrown.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.handle_error-Tuple{Exception}","page":"Private","title":"GraphQLClient.handle_error","text":"handle_error(::Exception)\nhandle_error(err::HTTP.StatusError)\n\nHandle the error caught during HTTP execution and deserialisation.\n\nIt the error is an HTTP.StatusError with status 400, a GraphQLError is thrown, otherwise the original error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.GQLError","page":"Private","title":"GraphQLClient.GQLError","text":"GQLError\n\nStruct to contain information for errors recieved from the GraphQL server.\n\n\n\n\n\n","category":"type"},{"location":"private/#GraphQLClient.GQLLocation","page":"Private","title":"GraphQLClient.GQLLocation","text":"GQLLocation\n\nStruct to contain the location of GraphQL errors.\n\n\n\n\n\n","category":"type"},{"location":"private/#GraphQLClient.GQLSubscriptionResponse","page":"Private","title":"GraphQLClient.GQLSubscriptionResponse","text":"GQLSubscriptionResponse{T}\n\nStruct for subsriptions that wraps a GQLReponse{T} alongside various metadata.\n\n\n\n\n\n","category":"type"},{"location":"private/#GraphQLClient.get_name-Tuple{AbstractString}","page":"Private","title":"GraphQLClient.get_name","text":"get_name(name::AbstractString)\nget_name(alias::Alias)\n\nTo be used when the GraphQL field name is required, which will either be inputted as a string or in the name field of an Alias.\n\n\n\n\n\n","category":"method"},{"location":"private/#Output-Fields","page":"Private","title":"Output Fields","text":"","category":"section"},{"location":"private/","page":"Private","title":"Private","text":"Modules = [GraphQLClient]\nPages   = [\"output_fields.jl\"]\nPublic = false","category":"page"},{"location":"private/#GraphQLClient._get_field_str-Tuple{Client, Any, Any, Any}","page":"Private","title":"GraphQLClient._get_field_str","text":"_get_fields_str(client::Client, field, objects_that_recurse)\n\nReturns a string containing all fields of the given field.\n\nIf field is not NON_NULL or an OBJECT, the name of the field is returned. Otherwise, the subfield(s) of the field are returned wrapped in {}.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.get_all_output_fields_str","page":"Private","title":"GraphQLClient.get_all_output_fields_str","text":"get_all_output_fields_str(client::Client, query_name, objects_to_ignore=String[])\n\nReturns a string containing all fields of the given query. To be used when returning all fields from a GQL query.\n\nThis could be used with mutations (untested), but the default mutation behaviour is to return nothing.\n\n\n\n\n\n","category":"function"},{"location":"private/#GraphQLClient.get_field_names_string-Tuple{Client, Any, Any, Any}","page":"Private","title":"GraphQLClient.get_field_names_string","text":"get_field_names_string(client::Client, query_name, objects_to_ignore, objects_that_recurse)\n\nReturns a string containing all fields of the given GQL schema type.\n\nGets all fields from type_to_fields_map and then recursively gets all fields.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.get_output_str-Tuple{Vector{T} where T}","page":"Private","title":"GraphQLClient.get_output_str","text":"get_output_str(outputs::Vector)\nget_output_str(output::String)\nget_output_str(output::Alias)\nget_output_str(output::Dict)\n\nReturn a String containing the output fields. Options:\n\nIf input arg is a Vector, get_output_str is called on each element.\nIf input arg is a String, the input is returned with a comma added.\nIf input is an Alias, \"$(Alias.alias):$(Alias.name),\" is returned.\nIf input arg is a Dict, the output creates a structured output string   based on the keys and values.\n\nExamples\n\njulia> str = get_output_str([\"Field1\", \"Field2\"])\n\"Field1,Field2,\"\njulia> println(prettify_query(str))\nField1\nField2\n\njulia> str = get_output_str(\"Field1\")\n\"Field1,\"\n\njulia> str = get_output_str([\"OuterField\", Dict(\"Outer\" => Dict(\"Inner\" => [\"Field1\", \"Field2\"]))])\n\"OuterField,Outer{Inner{Field1,Field2,},},\"\n\njulia> println(prettify_query(str))\nOuterField\nOuter{\n    Inner{\n        Field1\n        Field2\n    }\n}\n\n\n\n\n\n","category":"method"},{"location":"private/#Arguments","page":"Private","title":"Arguments","text":"","category":"section"},{"location":"private/","page":"Private","title":"Private","text":"Modules = [GraphQLClient]\nPages   = [\"args.jl\"]\nPublic = false","category":"page"},{"location":"private/#GraphQLClient._get_val_str-Tuple{String}","page":"Private","title":"GraphQLClient._get_val_str","text":"_get_val_str(val::String)\n_get_val_str(val::Dict)\n_get_val_str(val::Vector)\n_get_val_str(enum::GQLEnum) \n_get_val_str(val)\n\nReturn value string for directly_write_query_args\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.directly_write_query_args-Tuple{Any}","page":"Private","title":"GraphQLClient.directly_write_query_args","text":"directly_write_query_args(query_args)\n\nReturns a string which represents query_args by inserting values directly into the string. Strings are bracketed with \" as this is required by GraphQL, but unfortunately this does not work for ENUMs as we cannot tell if a string is meant to be an enum or not without introspection. Therefore, any enums must be wrapped by a GQLEnum.\n\nExamples\n\njulia> query_args = Dict(\"string\"=>\"my_string\", \"dict\"=>Dict(\"bool\"=>true,\"int\"=>1), \"vec\"=>[Dict(\"float\"=>1.0)])\nDict{String, Any} with 3 entries:\n  \"dict\"   => Dict{String, Integer}(\"int\"=>1, \"bool\"=>true)\n  \"string\" => \"my_string\"\n  \"vec\"    => [Dict(\"float\"=>1.0)]\n\njulia> println(prettify_query(directly_write_query_args(query_args)))\ndict:{\n    int:1\n    bool:true\n}\nstring:\"my_string\"\nvec:[\n    {\n        float:1.0\n    }\n]\n\njulia> query_args = Dict(\"string\"=>\"my_string\", \"enum\" => GQLEnum(\"my_enum\"))\nDict{String, Any} with 2 entries:\n  \"string\" => \"my_string\"\n  \"enum\"   => GQLEnum(\"my_enum\")\n\njulia> println(prettify_query(directly_write_query_args(query_args)))\nstring:\"my_string\"\nenum:my_enum\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.get_query_args_str-Tuple{AbstractDict}","page":"Private","title":"GraphQLClient.get_query_args_str","text":"get_query_args_str(args::AbstractDict)\n\nGet the mutation arguments string and a dictionary containing the argument names, which will not necessarily match the name of the types in the schema.\n\nUses an internal function to go through args dictionary, recursing down through the values that are  AbstractDict or Vector{<:AbstractDict}, ensuring that no argument name is duplicated and enumerating multiple of the same type if in a vector.\n\nExamples\n\njulia> args = Dict(\"TopLevelVarA\" => \"value\", \"TopLevelVarB\" => 2);\n\njulia> str, arg_names = get_query_args_str(args);\n\njulia> println(prettify_query(str))\n(\n    TopLevelVarA:$TopLevelVarA\n    TopLevelVarB:$TopLevelVarB\n)\n\njulia> args = Dict(\"A\" => \"value\", \"B\" => 2, \"C\" => Dict(\"D\" => 3, \"E\" => 4));\n\njulia> str, arg_names = get_query_args_str(args);\n\njulia> print(prettify_query(str))\n(\n    B:$B\n    A:$A\n    C:{\n        D:$D\n        E:$E\n    }\n)\n\njulia> args = Dict(\"A\" => \"value\", \"B\" => 2, \"C\" => [Dict(\"D\" => 3, \"E\" => 4), Dict(\"D\" => 5, \"E\" => 6), Dict(\"D\" => 7, \"E\" => 8)]);\n\njulia> str, arg_names = get_query_args_str(args);\n\njulia> print(prettify_query(str))\n(\n    B:$B\n    A:$A\n    C:[\n        {\n            D:$D1\n            E:$E1\n        }\n        {\n            D:$D2\n            E:$E2\n        }\n        {\n            D:$D3\n            E:$E3\n        }\n    ]\n)\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.initialise_arg_names-Tuple{Dict}","page":"Private","title":"GraphQLClient.initialise_arg_names","text":"initialise_arg_names(args::Dict)\n\nRecursively create arg_names Dict with same structure (dictionaries and vectors) and keys as args. Values are initialised as empty strings.\n\nExamples\n\njulia> args = Dict(\"int\" => 1, \"vector\" => [1, 2, 3], \"dict\" => Dict(\"float\" => 1.0), \"vec_dict\" => [Dict(\"bool\" => true)])\nDict{String, Any} with 4 entries:\n  \"int\"      => 1\n  \"dict\"     => Dict(\"float\"=>1.0)\n  \"vec_dict\" => Dict{String, Bool}[Dict(\"bool\"=>1)]\n  \"vector\"   => [1, 2, 3]\n\njulia> arg_names = initialise_arg_names(args)\nDict{String, Any} with 4 entries:\n  \"int\"      => \"\"\n  \"dict\"     => Dict{String, Any}(\"float\"=>\"\")\n  \"vec_dict\" => Dict{String, Any}[Dict(\"bool\"=>\"\")]\n  \"vector\"   => \"\"\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.is_field_name_used-Tuple{Any, Any}","page":"Private","title":"GraphQLClient.is_field_name_used","text":"is_field_name_used(fieldname, fieldnamelist)\n\nTrue if fieldname is in fieldnamelist.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.prettify_query-Tuple{Any}","page":"Private","title":"GraphQLClient.prettify_query","text":"prettify_query(str)\n\nPrettifies a string, nesting for bracket types and adding new lines for commas.\n\nExamples\n\njulia> println(GraphQLClient.prettify_query(\"[{(a)}]\"))\n[\n    {\n        (\n            a\n        )\n    }\n]\njulia> println(GraphQLClient.prettify_query(\"[{(a,b),(c,d)}]\"))\n[\n    {\n        (\n            a\n            b\n        )\n        (\n            c\n            d\n        )\n    }\n]\n\n\n\n\n\n","category":"method"},{"location":"private/#Variables","page":"Private","title":"Variables","text":"","category":"section"},{"location":"private/","page":"Private","title":"Private","text":"Modules = [GraphQLClient]\nPages   = [\"variables.jl\"]\nPublic = false","category":"page"},{"location":"private/#GraphQLClient.get_query_variables-Tuple{Any, Any}","page":"Private","title":"GraphQLClient.get_query_variables","text":"get_query_variables(args, arg_names)\n\nReturns single level dictionary with variable name and value as key val pairs.\n\nargs and arg_names must be dictionaries with the same structure and keys. args contains the original variable name and its value, arg_names contains the original variable name and the name being used in the query, which may be different from the original variable name, for example if multiple of the same original name are used.\n\nExamples\n\njulia> args = Dict(\"int\" => 1, \"vector\" => [1, 2, 3], \"dict\" => Dict(\"float\" => 1.0), \"vec_dict\" => [Dict(\"bool\" => true, \"int\" => 2)]);\n\njulia> _, arg_names = get_query_args_str(args);\n\njulia> arg_names\nDict{String, Any} with 4 entries:\n  \"int\"      => \"int\"\n  \"dict\"     => Dict{String, Any}(\"float\"=>\"float\")\n  \"vec_dict\" => Dict{String, Any}[Dict(\"int\"=>\"int__2\", \"bool\"=>\"bool__2\")]\n  \"vector\"   => \"vector__1\"\n\njulia> get_query_variables(args, arg_names)\nDict{String, Any} with 5 entries:\n  \"int\"       => 1\n  \"int__2\"    => 2\n  \"bool__2\"   => true\n  \"float\"     => 1.0\n  \"vector__1\" => [1, 2, 3]\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.get_variables_str-Tuple{Client, AbstractDict, AbstractDict, String}","page":"Private","title":"GraphQLClient.get_variables_str","text":"get_variables_str(client::Client,\n                  args::AbstractDict,\n                  arg_names::AbstractDict,\n                  query::String;\n                  typedict=client.query_to_args_map)\n\nReturns the variable string, not bracketed, for the args of a given query. For each variable, the string is:\n\n$var_name: var_type\n\nwhere var_name is specified in arg_names. This allows multiple args of the same type to be parameterised with different names. For queries and mutations, arg_names is calculated by get_query_args_str.\n\nArguments\n\nclient::Client: client.\nargs::AbstractDict: contains name of type and value of argument as key value pairs.   For nested arguments, the value should be a AbstractDict or Vector{<:AbstractDict}).   See examples below.\narg_names::AbstractDict: contains name of type and name to be used in variable string   as key value pairs. The structure and keys of arg_names should match that of args.\nquery::String: query/mutation/subscription name\ntypedict=client.query_to_args_map: dictionary to look up type in. For top level variables,   query_to_args_map is used. For lower level variables, type_to_fields_map is used.\n\nExamples\n\njulia> client = Client(\"https://countries.trevorblades.com\");\n\njulia> args = Dict(\"code\" => \"BR\");\n\njulia> arg_names = Dict(\"code\" => \"code1\");\n\njulia> str = get_variables_str(client, args, arg_names, \"country\")\n\"\\$code1: ID!,\"\n\n\n\n\n\n","category":"method"},{"location":"private/#Schema-Utilities","page":"Private","title":"Schema Utilities","text":"","category":"section"},{"location":"private/","page":"Private","title":"Private","text":"Modules = [GraphQLClient]\nPages   = [\"schema_utils.jl\"]\nPublic = false","category":"page"},{"location":"private/#GraphQLClient.GraphQLType","page":"Private","title":"GraphQLClient.GraphQLType","text":"Abstract type for GraphQL objects\n\n\n\n\n\n","category":"type"},{"location":"private/#GraphQLClient.InputObject","page":"Private","title":"GraphQLClient.InputObject","text":"InputObject type\n\n\n\n\n\n","category":"type"},{"location":"private/#GraphQLClient.Object","page":"Private","title":"GraphQLClient.Object","text":"Object type\n\n\n\n\n\n","category":"type"},{"location":"private/#GraphQLClient.get_field_type_string-Tuple{Any}","page":"Private","title":"GraphQLClient.get_field_type_string","text":"get_field_type_string(field)\n\nReturns string of the type of a GQL field by determining the kind of the field and acting accordingly.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.getjuliatype-Tuple{Any}","page":"Private","title":"GraphQLClient.getjuliatype","text":"getjuliatype(field; level=:top, scalar_types::Dict{String, DataType}=GQL_DEFAULT_SCALAR_TO_JULIA_TYPE)\n\nReturns type of a GraphQL field by determining the kind of the field and acting accordingly.\n\nArguments\n\nfield: introspected field dictionary.\nscalar_types::Dict{String, DataType}=GQL_DEFAULT_SCALAR_TO_JULIA_TYPE: optional dictionary   of scalar type name to Julia type which defaults to internal dictionary containing default   scalars only.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.getroottype-Tuple{Any}","page":"Private","title":"GraphQLClient.getroottype","text":"getroottype(field)\n\nGet the name of the root type of a field.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.getroottypefield-Tuple{Any}","page":"Private","title":"GraphQLClient.getroottypefield","text":"getroottypefield(field)\n\nGet the root type field of a NON_NULL or LIST field.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.getsubfield-Tuple{Any}","page":"Private","title":"GraphQLClient.getsubfield","text":"getsubfield(field)\n\nReturn field[\"type\"] or field[\"ofType\"], throwing an error if neither exist.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.isroottypeenum-Tuple{Any}","page":"Private","title":"GraphQLClient.isroottypeenum","text":"isroottypeenum(field)\n\nReturn true if field is an arbitrarily nested enum (nested in both NON_NULL and/or LISTs).\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.isroottypeobject-Tuple{Any}","page":"Private","title":"GraphQLClient.isroottypeobject","text":"isroottypeobject(field)\n\nReturn true if field is an arbitrarily nested enum (nested in both NON_NULL and/or LISTs).\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.isroottypescalar-Tuple{Any}","page":"Private","title":"GraphQLClient.isroottypescalar","text":"isroottypescalar(field)\n\nReturn true if field is an arbitrarily nested scalr (nested in both NON_NULL and/or LISTs).\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.istype-Tuple{Any, Any}","page":"Private","title":"GraphQLClient.istype","text":"istype(field, comparison)\n\nChecks whether kind of field (which has either type or ofType as a key) is comparison. Error if both type and ofType are not keys.\n\n\n\n\n\n","category":"method"},{"location":"private/#Type-Introspection","page":"Private","title":"Type Introspection","text":"","category":"section"},{"location":"private/","page":"Private","title":"Private","text":"Modules = [GraphQLClient]\nPages   = [\"type_construction.jl\"]\nFilter = t -> !in(t, (GraphQLClient.AbstractIntrospectedStruct,))\nPublic = false","category":"page"},{"location":"private/#GraphQLClient._instrospect_object-Tuple{Any, Any}","page":"Private","title":"GraphQLClient._instrospect_object","text":"_instrospect_object(client,\n                    object_name;\n                    objects_being_introspected=String[],\n                    parent_map=Dict{String, Type}(),\n                    mutable=true,\n                    allowed_level=2,\n                    scalar_types=GQL_DEFAULT_SCALAR_TO_JULIA_TYPE)\n\nCreate a new type from instrospection of the object specified by object_name. The name of the tupe is calculated by gen_sym(string(object_name))\n\nThis is an internal method that is called recursively.\n\nSee also: introspect_object.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.build_name_to_type-Tuple{Any, Any}","page":"Private","title":"GraphQLClient.build_name_to_type","text":"build_name_to_type(client,\n                   object_name;\n                   objects_being_introspected=String[],\n                   allowed_level=2,\n                   custom_scalar_types=GQL_DEFAULT_SCALAR_TO_JULIA_TYPE,\n                   kwargs...)\n\nBuilds a dictionary of field name to Julia type for the given object.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.create_struct_AST-Tuple{Symbol, Any, Any}","page":"Private","title":"GraphQLClient.create_struct_AST","text":"create_struct_AST(struct_name::Symbol, parent_type, fields, mutable=true)\n\nReturns an Expr which can be evaluated to create a struct. The struct has fields and types specifed by the key value pairs of fields, with all types being a union of Nothing and the type supplied. If the parent_type method is used the struct is given the supplied parent type. Mutability can be controlled with  the mutable kwarg.\n\n\n\n\n\n","category":"method"},{"location":"private/#Logging","page":"Private","title":"Logging","text":"","category":"section"},{"location":"private/","page":"Private","title":"Private","text":"Modules = [GraphQLClient]\nPages   = [\"logging.jl\"]\nPublic = false","category":"page"},{"location":"private/#GraphQLClient.output_debug-Tuple{Any}","page":"Private","title":"GraphQLClient.output_debug","text":"output_debug(verbose)\n\nUse to control whether or not a message should be printed that can be considered as a debug level message.\n\n\n\n\n\n","category":"method"},{"location":"private/#GraphQLClient.output_info-Tuple{Any}","page":"Private","title":"GraphQLClient.output_info","text":"output_info(verbose)\n\nUse to control whether or not a message should be printed that can be considered as a info level message.\n\n\n\n\n\n","category":"method"},{"location":"type_introspection/#type_introspection_page","page":"Type Introspection","title":"Type Introspection","text":"","category":"section"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"Pages = [\"type_introspection.md\"]\nDepth = 5","category":"page"},{"location":"type_introspection/#Overview","page":"Type Introspection","title":"Overview","text":"","category":"section"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"Because types are well defined in a GraphQL server and we can read the definition via introspection, we can build a Julia type for any GraphQL object.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> client = Client(\"https://countries.trevorblades.com\")\nGraphQLClient Client\n       endpoint: https://countries.trevorblades.com\n    ws_endpoint: wss://countries.trevorblades.com\n\njulia> T = introspect_object(client, \"Country\")\nGraphQLClient.var\"##Country#261\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"introspect_object creates a new, uniquely-named mutable type, which has a StructType of Struct() and where the type of every field is a Union of Nothing and the field type, . This makes the type flexible as it can be used for queries where not all field names are requested.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"We can use this as the output_type of a query","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> response = query(client, \"country\", T, query_args=Dict(\"code\"=>\"AU\"), output_fields=\"phone\")\nGraphQLClient.GQLResponse{GraphQLClient.var\"##Country#261\"}\n  data: Dict{String, Union{Nothing, GraphQLClient.var\"##Country#261\"}}\n          country: GraphQLClient.var\"##Country#261\"\n\njulia> country = response.data[\"country\"]\nCountry\n  phone : 61\n\njulia> country.phone\n\"61\"\n\njulia> isnothing(country.continent)\ntrue\n\njulia> propertynames(country)\n(:emoji, :currency, :states, :phone, :emojiU, :continent, :native, :capital, :name, :languages, :code)","category":"page"},{"location":"type_introspection/#Using-and-Initialising","page":"Type Introspection","title":"Using and Initialising","text":"","category":"section"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"The Type for an object can be accessed using get_introspected_type","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> get_introspected_type(client, \"Country\")\nGraphQLClient.var\"##Country#262\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"We can initialise an instance of the type with every field set to nothing","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> country = initialise_introspected_struct(client, \"Country\")\nCountry\n  All fields are nothing\n\njulia> country.name = \"Australia\"\n\"Australia\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"Or pass a dictionary of key value pairs to parameterise an instance of the type with","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> fields = Dict(\"name\" => \"Australia\", \"phone\" => \"61\");\n\njulia> create_introspected_struct(client, \"Country\", fields)\nCountry\n   name : Australia\n  phone : 61","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"Note, the latter method will not work if the mutable keyword argument of introspect_object is set to false.","category":"page"},{"location":"type_introspection/#Handling-Recursion-and-Nested-Objects","page":"Type Introspection","title":"Handling Recursion and Nested Objects","text":"","category":"section"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"GraphQL schemas can have objects as fields of other objects, and often these end up recursing. When an object is being introspected, any objects used in its fields are also introspected. For example, in the above introspection of Country, the object State is also introspected","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> get_introspected_type(client, \"State\")\nGraphQLClient.var\"##State#259\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"We can view all the introspected objects of a Client and see that four objects were actually introspected","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> list_all_introspected_objects(client)\n4-element Vector{String}:\n \"Continent\"\n \"State\"\n \"Country\"\n \"Language\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"GraphQLClient keeps track of all introspected objects so that if two fields use the same object, they use the same Julia type. This information is stored in client so that if other objects are introspected that use already-introspected objects they will use the already-introspected types. Furthermore, if the name of an already-introspected object is inputted to introspect_object, the -already introspected type will be returned.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"GraphQLClient also keeps track of the object(s) that is/are currently being introspected to  ensure that it doesn't attempt to introspect any of them again, which would lead to infinite recursion.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"For example in the above introspection of Country, we actually get the following warning messages which were ommited above","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> T = introspect_object(client, \"Country\")\n┌ Warning: Cannot introspect field country on type State due to recursion of object Country\n└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:75\n┌ Warning: Cannot introspect field countries on type Continent due to recursion of object Country\n└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:75\nGraphQLClient.var\"##Country#261\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"They indicate that during the introspection of Country, both State and Continent are being introspected. Both of these objects have fields which use Country, and therefore GraphQLClient cannot introspect these fields, otherwise we would be using the type that we are currently in the process of definining which therefore doesn't exist (i.e., the definition of the type for State would fail as the type for Country doesn't exist yet).","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"The allowed_level keyword argument can be used to control how deep an object is introspected (note in this example we using the force keyword argument to force the re-introspection of the object)","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> T = introspect_object(client, \"Country\", allowed_level=1, force=true)\n┌ Warning: Cannot introspect field languages on type Country due to allowed_level kwarg\n└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:78\n┌ Warning: Cannot introspect field states on type Country due to allowed_level kwarg\n└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:78\n┌ Warning: Cannot introspect field continent on type Country due to allowed_level kwarg\n└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:78\nGraphQLClient.var\"##Country#262\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"When setting this to 1 in this example, introspect_object will not include any fields of Country that are objects","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> fieldnames(T)\n(:emoji, :currency, :native, :code, :name, :phone, :capital, :emojiU)","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"Because of the nesting and recursion of objects, it is important to be careful with the order that objects are introspected and what level is allowed as this can affect the fields of introspected types. Considering State and Country in the above example, here are three possible outcomes:","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"If allowed_level=3 and Country is introspected first (State is introspected during the introspection of Country)","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> Country = introspect_object(client, \"Country\", allowed_level=3, force=true);\n\njulia> sort(collect(fieldnames(Country)))\n11-element Vector{Symbol}:\n :capital\n :code\n :continent\n :currency\n :emoji\n :emojiU\n :languages\n :name\n :native\n :phone\n :states\n\njulia> sort(collect(fieldnames(get_introspected_type(client, \"State\"))))\n2-element Vector{Symbol}:\n :code\n :name","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"If allowed_level=3 and State is introspected first (Client is introspected during the introspection of Country) we can see that State now has the field name and Country does not have the field states.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> State = introspect_object(client, \"State\", allowed_level=3, force=true);\n\njulia> sort(collect(fieldnames(State)))\n3-element Vector{Symbol}:\n :code\n :country\n :name\n\njulia> sort(collect(fieldnames(get_introspected_type(client, \"Country\"))))\n10-element Vector{Symbol}:\n :capital\n :code\n :continent\n :currency\n :emoji\n :emojiU\n :languages\n :name\n :native\n :phone","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"If allowed_level=1, both objects must be introspected separately and have fewer fields","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> State = introspect_object(client, \"State\", allowed_level=1, force=true);\n\njulia> sort(collect(fieldnames(State)))\n2-element Vector{Symbol}:\n :code\n :name\n\njulia> Country = introspect_object(client, \"Country\", allowed_level=1, force=true);\n\njulia> sort(collect(fieldnames(Country)))\n10-element Vector{Symbol}:\n :capital\n :code\n :currency\n :emoji\n :emojiU\n :name\n :native\n :phone","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"We can see that in each of the three scenarios, the types have different fields according to how they have been introspected.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"A more sophiscated solution could potentially use parametric typing to get around this and allow full recursion within defined types, but this is not implemented currently.","category":"page"},{"location":"type_introspection/#forcing_re-introspection","page":"Type Introspection","title":"Forcing Re-Introspection","text":"","category":"section"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"Fortunately, GraphQL schemas are typically fairly static so we shouldn't need to re-introspect an object too frequently. Howeve re-intropsection of an object and any objects used by its fields (and so on for those objects) can be forced using the force keyword argument. This should be done with care, however, as the following example illustrates.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"First we introspect Country, as we have done previously","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> Country = introspect_object(client, \"Country\")\nGraphQLClient.var\"##Country#403\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"Then we force re-introspect Language, which has already been introspected during the intropsection of Country","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> Language = introspect_object(client, \"Language\", force=true)\nGraphQLClient.var\"##Language#404\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"Now if we try to use them together, the type of Language will not match that of the languages field of Country","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> language = create_introspected_struct(client, \"Language\", Dict(\"name\" => \"English\"))\nLanguage\n  name : English\n\njulia> country = create_introspected_struct(client, \"Country\", Dict(\"languages\" => [language]))\nERROR: MethodError: Cannot `convert` an object of type GraphQLClient.var\"##Language#404\" to an object of type GraphQLClient.var\"##Language#400\"","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"It is safer to use the reset_all keyword argument once to delete all introspected types and start again.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> Language = introspect_object(client, \"Language\", reset_all=true);\n\njulia> Country = introspect_object(client, \"Country\");\n\njulia> language = create_introspected_struct(client, \"Language\", Dict(\"name\" => \"English\"))\nLanguage\n  name : English\n\njulia> country = create_introspected_struct(client, \"Country\", Dict(\"languages\" => [language]))\nCountry\n  languages : GraphQLClient.var\"##Language#405\"[GraphQLClient.var\"##Language#405\"(nothing, nothing, nothing, \"English\")]","category":"page"},{"location":"type_introspection/#Parent-Types","page":"Type Introspection","title":"Parent Types","text":"","category":"section"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"By default, all introspected types have the parent type GraphQLClient.AbstractIntrospectedStruct, which has a defined StructType of Struct. However it may be desirable to change this for multiple dispatch or display purposes. This can be done in two ways in two ways.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"The parent_type keyword argument sets the parent type of the top level object being introspected, but no nested objects.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> abstract type MyType end\n\njulia> Country = introspect_object(client, \"Country\", parent_type=MyType, force=true);\n\njulia>  Country <: MyType\ntrue\n\njulia> get_introspected_type(client, \"State\") <: MyType\nfalse","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"Alternatively, a dictionary mapping object name to parent type can be supplied to the parent_map keyword argument. Any object that is not in the map will have the default parent type.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> parent_map = Dict(\"Country\" => MyType, \"State\" => MyType)\njulia> Country = introspect_object(client, \"Country\", parent_map=parent_map, force=true);\n\njulia> Country <: MyType\ntrue\n\njulia> get_introspected_type(client, \"State\") <: MyType\ntrue\n\njulia> get_introspected_type(client, \"Continent\") <: MyType # not in parent_map\nfalse","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"If both parent_type and parent_map are supplied, parent_type take precedence.","category":"page"},{"location":"type_introspection/#Custom-Scalar-Types","page":"Type Introspection","title":"Custom Scalar Types","text":"","category":"section"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"If the GraphQL server has custom scalar types defined and these are used by the object(s) being intropsected, then they must be mapped to Julia types in the custom_scalar_types keyword argument of introspect_object.","category":"page"},{"location":"type_introspection/","page":"Type Introspection","title":"Type Introspection","text":"julia> custom_scalar_types = Dict(\"ScalarTypeName\" => Int8)","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"GraphQLClient.jl follows the ColPrac guide for collaborative practices. New contributors should make sure to read that guide and then please do get involved!","category":"page"},{"location":"public/#Public","page":"Public","title":"Public","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"public/","page":"Public","title":"Public","text":"Documentation for GraphQLClient's public interface.","category":"page"},{"location":"public/#Client","page":"Public","title":"Client","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Client\nglobal_graphql_client\nfull_introspection!\nget_queries\nget_mutations\nget_subscriptions","category":"page"},{"location":"public/#GraphQLClient.Client","page":"Public","title":"GraphQLClient.Client","text":"Client(endpoint; headers=Dict(), introspect=true)\nClient(endpoint, ws_endpoint; headers=Dict(), introspect=true)\n\nGraphQL client. If just endpoint is provided, ws_endpoint is assumed to be the same as endpoint with \"http\" replaced by \"ws\".\n\nBy default, introspection will be performed on the client. This can be turned off by setting the introspect keyword argument to false.\n\nFields - Public Interface\n\nendpoint::String: endpoint for queries and mutations.\nws_endpoint::String: endpoint for subscriptions.\nheaders::Dict: contains client specific headers.\nintrospection_complete::Bool: set to true once introspection has been performed.\nqueries::Vector{String}: list of available queries.\nmutations::Vector{String}: list of available mutations.\nsubscriptions::Vector{String}: list of available subscriptions.\n\nFields - Internal Use\n\ntype_to_fields_map::Dict{String, Dict{String, Dict{String, Any}}}: maps GQL types   to their fields.\nquery_to_type_map::Dict{String, String}: maps GQL queries, mutations and   subscriptions to the type(s) of their outputs(s).\nquery_to_args_map::Dict{String, Dict{String, String}}: maps GQL queries, mutations   and subscriptions to their arguments and types.\ninput_object_fields_to_type_map::Dict{String, Dict{String, String}}: maps GQL input   objects to their fields/types.\nschema::Dict{String, Any}: full schema of server.\nintrospected_types::Dict{String, DataType}: dictionary containing all introspected types.\n\nExamples\n\njulia> client = Client(\"https://countries.trevorblades.com\")\nGraphQLClient Client\n       endpoint: https://countries.trevorblades.com\n    ws_endpoint: wss://countries.trevorblades.com\n\njulia> client = Client(\"https://countries.trevorblades.com\", \"wss://countries.trevorblades.com\")\nGraphQLClient Client\n       endpoint: https://countries.trevorblades.com\n    ws_endpoint: wss://countries.trevorblades.com\n\n\n\n\n\n","category":"type"},{"location":"public/#GraphQLClient.global_graphql_client","page":"Public","title":"GraphQLClient.global_graphql_client","text":"global_graphql_client()\n\nRetrieve the global Client.\n\n\n\n\n\nglobal_graphql_client(client::Client)\n\nSet the global Client.\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.full_introspection!","page":"Public","title":"GraphQLClient.full_introspection!","text":"full_introspection!(client::Client)\n\nPerforms a full instrospection of the GraphQL schema of the client. The results are stored in the client struct.\n\nSee also: Client\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.get_queries","page":"Public","title":"GraphQLClient.get_queries","text":"get_queries(client::Client)\n\nReturns all queries available from GraphQL server. If introspection has not been performed, will run full_introspection!(client).\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.get_mutations","page":"Public","title":"GraphQLClient.get_mutations","text":"get_mutations(client::Client)\n\nReturns all mutations available from GraphQL server. If introspection has not been performed, will run full_introspection!(client).\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.get_subscriptions","page":"Public","title":"GraphQLClient.get_subscriptions","text":"get_subscriptions(client::Client)\n\nReturns all subscriptions available from GraphQL server. If introspection has not been performed, will run full_introspection!(client).\n\n\n\n\n\n","category":"function"},{"location":"public/#Operations","page":"Public","title":"Operations","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"query\nmutate\nopen_subscription\nGraphQLClient.execute\nGraphQLClient.GQLResponse\nGraphQLClient.GQLEnum\nGraphQLClient.Alias","category":"page"},{"location":"public/#GraphQLClient.query","page":"Public","title":"GraphQLClient.query","text":"query([client::Client], query_name::Union{Alias, AbstractString}, output_type::Type=Any; kwargs...)\n\nPerform a query on the server, using the global client if client not supplied.\n\nIf no output_fields are supplied, all possible fields (determined by introspection of client) are returned.\n\nThe query uses the endpoint field of the client.\n\nBy default query returns a GQLReponse{Any}, where the data for an individual query can be found by gql_response.data[query_name].\n\nArguments\n\nclient::Client: GraphQL client (optional). If not supplied, global_graphql_client is used.\nquery_name::Union{Alias, AbstractString}: name of query in server.\noutput_type::Type=Any: output data type for query response object. An object of type   GQLResponse{output_type} will be returned. For further information, see documentation   for GQLResponse.\n\nKeyword Arguments\n\nquery_args=Dict(): dictionary of query argument key value pairs - can be   nested with dictionaries and vectors.\noutput_fields=String[]: output fields to be returned. Can be a string, or   composed of dictionaries and vectors. If empty, query will attempt to return   all fields.\ndirect_write=false: if true, the query is formed by generating a string   from query_args directly, and the introspected schema is not used. Any ENUMs   must be wrapped in a GQLEnum. See directly_write_query_args for   more information.\nretries=1: number of times the mutation will be attempted before erroring.\nreadtimeout=0: HTTP request timeout length. Set to 0 for no timeout.\nthrow_on_execution_error=false: set to true to throw an exception if the GraphQL server   response contains errors that occurred during execution.\nverbose=0: set to 1, 2 for extra logging.\n\nSee also: GQLResponse\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.mutate","page":"Public","title":"GraphQLClient.mutate","text":"mutate([client::Client], mutation_name::Union{Alias, AbstractString}, args::AbstractDict, output_type::Type=Any; kwargs...)\n\nPerform a mutation on the server, using the global client if client not supplied.\n\nIf no output_fields are supplied, none are returned.\n\nBy default mutate returns a GQLReponse{Any}, where the data for an individual mutation can be found by gql_response.data[mutation_name].\n\nThe mutation uses the endpoint field of the client.\n\nArguments\n\nclient::Client: GraphQL client (optional). If not supplied, global_graphql_client is used.\nmutation_name::Union{Alias, AbstractString}: name of mutation_name.\nargs: dictionary of mutation argument key value pairs - can be nested with   dictionaries and vectors.\noutput_type::Type=Any: output data type for query response object. An object of type   GQLResponse{output_type} will be returned.For further information, see documentation   for GQLResponse.\n\nKeyword Arguments\n\noutput_fields=String[]: output fields to be returned. Can be a string, or   composed of dictionaries and vectors.\ndirect_write=false: if true, the query is formed by generating a string   from args directly, and the introspected schema is not used. Any ENUMs   must be wrapped in a GQLEnum. See directly_write_query_args for   more information.\nretries=1: number of times the mutation will be attempted before erroring.\nreadtimeout=0: HTTP request timeout length. Set to 0 for no timeout.\nthrow_on_execution_error=false: set to true to throw an exception if the GraphQL server   response contains errors that occurred during execution.\n\nSee also: GQLResponse\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.open_subscription","page":"Public","title":"GraphQLClient.open_subscription","text":"open_subscription(fn::Function,\n                  [client::Client],\n                  subscription_name::Union{Alias, AbstractString},\n                  output_type::Type=Any;\n                  sub_args=Dict(),\n                  output_fields=String[],\n                  initfn=nothing,\n                  retry=true,\n                  subtimeout=0,\n                  stopfn=nothing,\n                  throw_on_execution_error=false)\n\nSubscribe to subscription_name, running fn on each received result and ending the subcription when fn returns true.\n\nBy default fn receives a GQLReponse{Any}, where the data for an individual result object can be found by gql_response.data[subscription_name].\n\nIf used, initfn is called once the subscription is open.\n\nThe subscription uses the ws_endpoint field of the client.\n\nThis function is designed to be used with the do keyword.\n\nArguments\n\nfn::Function: function to be run on each result, recieves the response from the   subscription. Must return a boolean to indicate whether or not to close the subscription,   withtrue` closing the subscription.\nclient::Client: GraphQL client (optional). If not supplied, global_graphql_client is used.\nsubscription_name::Union{Alias, AbstractString}: name of subscription in server.\noutput_type::Type=Any: output data type for subscription response object. An object   of type GQLResponse{output_type} will be returned.For further information, see   documentation for GQLResponse.\n\nKeyword Arguments\n\nsub_args=Dict(): dictionary of subscription argument key value pairs - can be   nested with dictionaries and vectors.\noutput_fields=String[]: output fields to be returned. Can be a string, or   composed of dictionaries and vectors.\ninitfn=nothing: optional function to be run once subscription is itialised.\nretry=true: retry if subscription fails to open.\nsubtimeout=0: if stopfn supplied, this is the period that it is called at.   If stopfn is not supplied, this is the timeout for waiting for data. The timer   is reset after every subscription result is received.\nstopfn=nothing: a function to be called every subtimeout that stops the   subscription if it returns positive. The timer is reset after every subscription   result is received.\nthrow_on_execution_error=false: set to true to stop an error being thrown if the GraphQL server   response contains errors that occurred during execution.\nverbose=0: set to 1, 2 for extra logging.\n\nExamples\n\njulia> open_subscription(\"subSaveUser\", sub_args=Dict(\"role\" => \"SYSTEM_ADMIN\")) do result\n           fn(result)\n       end\n\nSee also: GQLResponse\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.execute","page":"Public","title":"GraphQLClient.execute","text":"execute([client::Client], query::AbstractString, output_type::Type{T}=Any; kwargs...) where T\nexecute([client::Client], payload::AbstractDict, output_type::Type{T}=Any; kwargs...) where T\nexecute(endpoint::AbstractString, query::AbstractString, headers::AbstractDict=Dict(), output_type::Type{T}=Any; variables=Dict(), kwargs...) where T\nexecute(endpoint::AbstractString, payload::AbstractDict, headers::AbstractDict=Dict(), output_type::Type{T}=Any; kwargs...) where T\n\nExecutes a HTTP Post request and returns the result as a GQLResponse{T}.\n\nThis function allows for lower level querying of the GraphQL server. A Client, the global client or endpoint can be queried with a query string (and optionally variables can be supplied to the keyword argument), or with the payload directly. This payload is typically a dictionary containing the key \"query\" at a minimum, with variables (and other keys) begin optional.\n\nFor all methods, the content type is set to application/json unless this is set differently in client.headers./headers.\n\nKeyword Arguments\n\nvariables=Dict(): dictionary of variable name to value, used to construct the payload.\nretries=1: number of times to retry.\nreadtimeout=0: close the connection if no data is received for this many seconds.   Use readtimeout = 0 to disable.\nthrow_on_execution_error=false: set to true to throw an exception if the GraphQL   server response contains errors that occurred during execution. Otherwise, errors   can be found in the error field of the return value.\n\nSee also: Client, GQLResponse\n\nExamples\n\njulia> client = Client(\"https://countries.trevorblades.com\");\n\njulia> GraphQLClient.execute(client, \"query{country(code:\\\"BR\\\"){name}}\")\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n      country: Dict{String, Any}\n\njulia> global_graphql_client(Client(\"https://countries.trevorblades.com\"));\n\njulia> GraphQLClient.execute(\"query{country(code:\\\"BR\\\"){name}}\")\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n      country: Dict{String, Any}\n\njulia> GraphQLClient.execute(\"https://countries.trevorblades.com\", \"query{country(code:\\\"BR\\\"){name}}\")\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n      country: Dict{String, Any}\n\njulia> GraphQLClient.execute(\n           \"https://countries.trevorblades.com\",\n           Dict(\"query\" => \"query{country(code:\\\"BR\\\"){name}}\")\n       )\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n      country: Dict{String, Any}\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.GQLResponse","page":"Public","title":"GraphQLClient.GQLResponse","text":"GQLResponse{T}\n\nOutput format for GraphQL queries, mutations and subscriptions.\n\nAccessing data\n\nThe data field of a GQLResponse object is a Union{Nothing, Dict{String, Union{Nothing, T}}}, where the key is the query, mutation or subscription name (or Alias) and T is specified in the output_type argument of query, mutate, open_subscription and execute. If this argument is not supplied, it will default to Any. Typically this results in combinations of dictionaries and vectors which can be accessed intuitively, following the GraphQL server schema. Alternatively, if execution of a particular query fails, the value for that query will be nothing.\n\nIt is, however, possible to provide types with a StructTypes definition and GraphQLClient will attempt to build the object from the response. This must be done carefully, however, as if the response is not as expected (for example, missing fields or unexpected nulls) then the deserialisation of the response into the struct can fail. If this occurs it should be indicated by the warnings and errors outputted by GraphQLClient.\n\nThe fields of the type to deserialise can be modified to be a Union of Nothing and their original type, as the deserialisation will input Nothing if the field is missing or null.\n\nComparison with GraphQL Response Specification\n\nThe GraphQL specification specifies that the response can contain data, errors  and extensions fields. It is important to note that in a GQLResponse object, both data and errors fields will always be present, regardless of whether or not they are returned in the server response. This is to ensure queries can be type stable. If errors is nothing, then no errors occurred.  If data is null this indicates an error occurred either during or before execution.\n\n\n\n\n\n","category":"type"},{"location":"public/#GraphQLClient.GQLEnum","page":"Public","title":"GraphQLClient.GQLEnum","text":"GQLEnum\n\nWhen using direct_write=true in queries and mutations, ENUMs must be wrapped in this type to ensure that they are not wrapped in quotes in the query string.\n\nSee directly_write_query_args for more information and examples.\n\n\n\n\n\n","category":"type"},{"location":"public/#GraphQLClient.Alias","page":"Public","title":"GraphQLClient.Alias","text":"Alias\n\nContains an alias for a GraphQL field or query. Aliases can be used in the output_fields keyword argument as well as directly instead of query, mutation and subscription names.\n\nExamples\n\nUsing an Alias instead of the query name:\n\njulia> client = Client(\"https://countries.trevorblades.com\");\n\njulia> alias = Alias(\"country_alias\", \"country\");\n\njulia> query(client, alias, query_args=Dict(\"code\"=>\"BR\"), output_fields=[\"name\"]).data\nDict{String, Any} with 1 entry:\n  \"country_alias\" => Dict{String, Any}(\"name\"=>\"Brazil\")\n\n\nUsing an Alias in output_fields:\n\njulia> field_alias = Alias(\"country_name_alias\", \"name\");\n\njulia> query(client, \"country\", query_args=Dict(\"code\"=>\"BR\"), output_fields=[field_alias]).data\nDict{String, Any} with 1 entry:\n  \"country\" => Dict{String, Any}(\"country_name_alias\"=>\"Brazil\")\n\n\n\n\n\n","category":"type"},{"location":"public/#Type-Introspection","page":"Public","title":"Type Introspection","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"introspect_object\nget_introspected_type\nlist_all_introspected_objects\ninitialise_introspected_struct\ncreate_introspected_struct\nGraphQLClient.AbstractIntrospectedStruct","category":"page"},{"location":"public/#GraphQLClient.introspect_object","page":"Public","title":"GraphQLClient.introspect_object","text":"introspect_object([client::Client],\n                  object_name;\n                  force=false,\n                  reset_all=false,\n                  parent_type=nothing,\n                  parent_map=Dict{String, Type}(),\n                  mutable=true,\n                  allowed_level=2,\n                  custom_scalar_types=Dict{String, DataType}())\n\nIntrospects an object and creates a Julia type.\n\nDue to the recursion that is possible with GraphQL schemas, this introspection can be difficult. Please read this docstring carefully.\n\nParent Type\n\nAll introspected type, by default, will be given the parent type AbstractIntrospectedStruct. The parent type of the top level object being introspected can be set by parent_type, and the parent types of any object being introspected can be set using the parent_map dictionary. If object_type is a key in parent_map and parent_type is not nothing, the value of parent_type will take precedence.\n\nStructTypes\n\nAbstractIntrospectedStruct has a defined StructType of Struct for JSON serialisation. You can define StructTypes for the concrete type that is introspected by doing\n\nStructTypes.StructType(::Type{GraphQLClient.get_introspected_object(object_name)}) = StructTypes.Struct()\n\nRecursion\n\nRecursion is handled by two methods:\n\nProviding the allowed_level kwarg to control how deep introspection goes.\nMaintaining a list of objects that are currently being introspected. No object can be instrospected  twice and a type cannot be used in a type definition until it has been defined itself. Therefore  if this situation occurs, the fields that need to use the not-yet-defined type are ignored.  This means the order in which objects are intropsected can have an impact on the final structs.\n\nFor example consider the following objects\n\nCountry:\n - name: String\n - leader: Person\n\nPerson:\n - name: String\n - countryOfBirth: Country\n\nIf we introspected Country first, the Person object would not contain the countryOfBirth field, as it is impossible to set the type of that field to Country before it is defined itself. If we introspected Person first, the Country boject would not contain the leader field for the same reason.\n\nKeyword Arguments\n\nforce=false: if false, the introspection will use already introspected types for objects   if they exist. If true, any previously introspected types will be overwritten if they   are introspected whilst introspecting object_name. Use with caution, as other types   may rely on types that are then overwritten.\nreset_all: delete all introspected types to start from a clean sheet.\nparent_type=nothing: the parent type to give to the new introspected struct. See   comment above.\nparent_map=Dict{String, Type}(): dictionary to maps   object names to desired parent types. If parent_type is supplied, this value   will take precedence over the entry in parent_map for object_name.\nmutable=true: boolean to set the mutability of top level and all lower level types.\nallowed_level=2: how many levels of introspection are allowed. For example, if this   is 1 then only top level fields that are objects will be in the introspected type.\ncustom_scalar_types: dictionary of custom GraphQL scalar type to Julia type. This kwarg enables   custom scalar types to be introspected to the correct type.\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.get_introspected_type","page":"Public","title":"GraphQLClient.get_introspected_type","text":"get_introspected_type([client::Client], object_name::String)\n\nReturn the introspected Type for an object.\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.list_all_introspected_objects","page":"Public","title":"GraphQLClient.list_all_introspected_objects","text":"list_all_introspected_objects([client::Client])\n\nReturn a Vector of the objects which have been introspected.\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.initialise_introspected_struct","page":"Public","title":"GraphQLClient.initialise_introspected_struct","text":"initialise_introspected_struct([client::Client], name::String)\ninitialise_introspected_struct([client::Client], name::SubString)\ninitialise_introspected_struct(T::Type)\n\nInitialise an introspected struct with all fields set to nothing. If name of type supplied as string, this get the Type from client.introspected_types.\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.create_introspected_struct","page":"Public","title":"GraphQLClient.create_introspected_struct","text":"create_introspected_struct([client::Client], object_name::AbstractString, fields::AbstractDict)\n\nCreates a struct for the object specified and populates its fields with the keys and values of fields.\n\nExamples\n\njulia> GraphQLClient.create_introspected_struct(\"ResultObject\",Dict(:resultId=>\"MyResult\", :Score => 1.0))\nResultObject\n  Score : 1.0\n      resultId : MyResult\n\n\n\n\n\n","category":"function"},{"location":"public/#GraphQLClient.AbstractIntrospectedStruct","page":"Public","title":"GraphQLClient.AbstractIntrospectedStruct","text":"AbstractIntrospectedStruct\n\nDefault supertype for introspected structs.\n\n\n\n\n\n","category":"type"},{"location":"limitations/#Current-Limitations","page":"Current Limitations","title":"Current Limitations","text":"","category":"section"},{"location":"limitations/","page":"Current Limitations","title":"Current Limitations","text":"Please see the issues for an up-to-date status of this package, let us know what you'd like us to be working on and contribute!","category":"page"},{"location":"#GraphQLClient.jl","page":"Home","title":"GraphQLClient.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia GraphQL client for seamless integration with a server","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is intended to make connecting to and communicating with GraphQL servers easy whilst integrating easily with the wider Julia ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"What is GraphQL? It is a \"query language for APIs and a runtime for fulfilling those queries with your existing data\". For further information, see https://graphql.org.","category":"page"},{"location":"#Key-Features-of-GraphQLClient","page":"Home","title":"Key Features of GraphQLClient","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Querying, mutating and subscribing without manual writing of query strings\nDeserializing responses directly using StructTypes\nType stable querying\nConstruction of Julia types from GraphQL objects\nUsing introspection to help with querying","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: There is plenty more to come\nGraphQL is a featureful language, and we are working to bring in new features to meet all of the specification. Please see the issues, let us know what you'd like us to be working on and contribute!","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"#Connecting-to-a-server","page":"Home","title":"Connecting to a server","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A client can be instantiated by using the Client type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GraphQLClient\n\njulia> client = Client(\"https://countries.trevorblades.com\")\nGraphQLClient Client\n       endpoint: https://countries.trevorblades.com\n    ws_endpoint: wss://countries.trevorblades.com","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will, by default, use a query to introspect the server schema, populating several fields of the Client object which can then be used to help with querying.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can set a global client to be used by query, mutate, open_subscription and GraphQLClient.execute.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> global_graphql_client(Client(\"https://countries.trevorblades.com\"))\nGraphQLClient Client\n       endpoint: https://countries.trevorblades.com\n    ws_endpoint: wss://countries.trevorblades.com","category":"page"},{"location":"","page":"Home","title":"Home","text":"And access the global client with the same function","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> global_graphql_client()\nGraphQLClient Client\n       endpoint: https://countries.trevorblades.com\n    ws_endpoint: wss://countries.trevorblades.com","category":"page"},{"location":"#Querying","page":"Home","title":"Querying","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using GraphQLClient\n    client = Client(\"https://countries.trevorblades.com\")\n    query_args = Dict(\"filter\" => Dict(\"code\" => Dict(\"eq\" => \"AU\")))\n    query_alias = Alias(\"country_names\", \"countries\")\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we have a Client object, we can query it without having to type a full GraphQL query by hand (note, you should be able to test these queries for yourself, thanks to https://github.com/trevorblades/countries).","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> response = query(client, \"countries\")\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n    countries: Vector{Any}\n\njulia> response.data[\"countries\"]\n250-element Vector{Any}:\n Dict{String, Any}...","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this case, GraphQLClient used the introspected schema to determine what output fields were available (with some limitations to avoid recursing infinitely). Alternatively, we can specify what fields we would like to be returned","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> response = query(client, \"countries\", output_fields=\"name\")\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n          country_names: Vector{Any}\n\njulia> response.data[\"countries\"]\n250-element Vector{Any}:\n Dict{String, Any}(\"name\" => \"Andorra\")\n Dict{String, Any}(\"name\" => \"United Arab Emirates\")\n Dict{String, Any}(\"name\" => \"Afghanistan\")\n Dict{String, Any}(\"name\" => \"Antigua and Barbuda\")\n⋮","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can add arguments to the query","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> query_args = Dict(\"filter\" => Dict(\"code\" => Dict(\"eq\" => \"AU\"))); # Filter for countries with code equal to AU\n\njulia> response = query(client, \"countries\"; query_args=query_args, output_fields=\"name\");\n\njulia> response.data[\"countries\"]\n1-element Vector{Any}:\n Dict{String, Any}(\"name\" => \"Australia\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can use an alias to change the name of either a query or a field in our results","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> query_alias = Alias(\"country_names\", \"countries\");\n\njulia> response = query(client, query_alias, query_args=query_args, output_fields=\"name\")\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n          country_names: Vector{Any}\n\njulia> response.data[\"country_names\"]\n1-element Vector{Any}:\n Dict{String, Any}(\"name\" => \"Australia\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can define a StructType to deserialise the result into","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using StructTypes\n\njulia> struct CountryName\n           name::String\n       end\n\njulia> StructTypes.StructType(::Type{CountryName}) = StructTypes.OrderedStruct()\n\njulia> response = query(client, query_alias, Vector{CountryName}, query_args=query_args, output_fields=\"name\")\nGraphQLClient.GQLResponse{Vector{CountryName}}\n  data: Dict{String, Union{Nothing, Vector{CountryName}}}\n          country_names: Vector{CountryName}\n\njulia> response.data[\"country_names\"][1]\nCountryName(\"Australia\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or we can use introspection to build the type automatically","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Country = GraphQLClient.introspect_object(client, \"Country\")\n┌ Warning: Cannot introspect field country on type State due to recursion of object Country\n└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:75\n┌ Warning: Cannot introspect field countries on type Continent due to recursion of object Country\n└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:75\nGraphQLClient.var\"##Country#604\"\n\njulia> response = query(client, query_alias, Vector{Country}, query_args=query_args, output_fields=\"name\")\nGQLResponse{Vector{GraphQLClient.var\"##Country#604\"}}\n  data: Dict{String, Union{Nothing, Vector{GraphQLClient.var\"##Country#604\"}}}\n          country_names: Vector{GraphQLClient.var\"##Country#604\"}\n\njulia> response.data[\"country_names\"][1]\nCountry\n  name : Australia","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = nothing","category":"page"},{"location":"#Mutations","page":"Home","title":"Mutations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mutations can be constructed in a similar way, except the arguments are not a keyword argument as typically a mutation is doing something with an input. For example","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> response = mutate(client, \"mutation_name\", Dict(\"new_id\" => 1))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unlike with query, the output fields are not introspected as mutations often do not have a response.","category":"page"},{"location":"#Subscriptions","page":"Home","title":"Subscriptions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The subscriptions syntax is similar, except that we use Julia's do notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"open_subscription(\n    client,\n    \"subscription_name\",\n    sub_args=(\"id\" => 1),\n    output_fields=\"val\"\n) do response\n    val = response.data[\"subscription_name\"][\"val\"]\n    stop_sub = val == 2\n    return stop_sub # If this is true, the subscription ends\nend","category":"page"},{"location":"#Use-with-Microservices-Architectures","page":"Home","title":"Use with Microservices Architectures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphQL is often used with microservice architectures. Often, you will find that you have multiple microservices that perform the same GraphQL queries. A nice solution to this is to write a new package which wraps GraphQLClient and provides a higher-level interface, and which also handles connection to the server. For example, the country query above could be wrapped as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"const CLIENT = Ref(Client)\n\nfunction connect()\n    CLIENT[] = Client(\"url\",\"ws\")\nend\n\nfunction get_country(code)\n    response = query(\n        CLIENT[],\n        \"country\",\n        query_args=Dict(\"code\"=>code),\n        output_fields=\"name\"\n    )\n    return response.data[\"country]\nend\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information, see this JuliaCon talk","category":"page"},{"location":"","page":"Home","title":"Home","text":"<center>\n<iframe width=\"560\" style=\"height:315px\" src=\"https://www.youtube.com/embed/KixO3udfcKA?start=1104\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</center>","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Pages = [\"operations.md\"]\nDepth = 5","category":"page"},{"location":"operations/#Overview","page":"Operations","title":"Overview","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"As per the specification, a GraphQL operation can be one of three types:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"query, a read-only fetch\nmutation, a write followed by a fetch\nsubscription, a long-lived request that fetches data in response to source events","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"There three operations can be performed using the query, mutate and open_subscription functions. These three functions share a lot of common functionality which serves to build the query string by","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Setting the operation type depending on the function used (i.e., for the query function the operation type is query)\nTaking the query, mutation or subscription name and setting it as the top level field\nBuilding an arguments string for this top level field and, if required, an associated dictionary of variable definitions\nUsing the output_field keyword argument to form the rest of the query string. (Note,   \"output field\" is not a term that you will find in the GraphQL specification.   We use it here to refer to any fields that are not the top level field).","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"As an example, consider an imaginary GraphQL server","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"query(\"get_countries\", query_args=Dict(\"name\" => \"Australia\"), output_fields=\"states\")","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"becomes a query string of","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"{\n    get_countries($name: String){\n        states\n    }\n}","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"and a variables dictionary of","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"{\n    \"name\": \"Australia\"\n}","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"which together form the payload to the GraphQL server.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"These three functions read the response from the server, process it and return a GQLReponse{T} object, where T defaults to Any but is configurable - see Response.","category":"page"},{"location":"operations/#Executing-an-Operation","page":"Operations","title":"Executing an Operation","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"A query, mutation or subscription can be selected by inputting its name as the first positional argument of query, mutate and open_subscription respectively. These names can be strings or Aliases.","category":"page"},{"location":"operations/#Arguments","page":"Operations","title":"Arguments","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"query, mutate and open_subscription accept arguments for the top level field (i.e., the query, mutation or subscription) via a positional argument in the case of mutate, and via the query_args and sub_args keyword arguments for query and open_subscription respectively. Because a mutation is a write followed by a read, it will typically always have arguments associated with it, and therefore for mutate it is not a keyword argument. Arguments for output fields are currently not implemented.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Arguments for the operation are supplied as a dictionary, the keys of which are Strings or  Symbols and the fields of which can be any combination of scalar values, dictionaries for  input objects or vectors of dictionaries for lists of input objects.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"The example below shows some of the possible inputs to give an idea of what is possible. The structure of the arguments will depend on the GraphQL schema.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"args = Dict(\n    \"arg1\" => \"word\",\n    \"arg2\" => [1,2,3],\n    \"arg3\" => Dict(\n        \"arg1\" => true,\n        \"arg4\" => [\n            Dict(\"arg10\" => 1.0),\n            Dict(\"arg10\" => 2.0),\n        ]\n    )\n)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"There are two options for how the arguments are constructed into the operation, the choice of which is controlled by the direct_write keyword argument.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"direct_write=false (default), argument values are supplied in a variables along with the query string.\ndirect_write=true, argument values are directly written into the query string.","category":"page"},{"location":"operations/#variables_section","page":"Operations","title":"Using Variables","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"When the direct_write keyword argument is false, the arguments will be written into a query string and a variables dictionary that is sent with the string. Assuming that arguments in the example above are for for a query called MyQuery, the query string would be as follows (with exact types depending on the schema):","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"MyQuery(\n    $arg1: String\n    $arg2: [Int]\n    $arg1__1: Boolean\n    $arg10__2: Float\n    $arg10__3: Float\n){\n    arg1: $arg1\n    arg2: $arg2\n    arg3: {\n        arg1: $arg1__1\n        arg2: [\n            {arg10: $arg10__2}\n            {arg10: $arg10__3}\n        ]\n    }\n}","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"And the variables dictionary (once serialised as a JSON) would be","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"{\n    \"arg1\": \"word\",\n    \"arg2\": [1,2,3],\n    \"arg1__1\": true,\n    \"arg10__2\": 1.0,\n    \"arg10__3\": 2.0\n}","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Repeated argument names (for example, in lists of input objects or objects with the same field names) are handled by appending the name with a double score and an incrementing count.","category":"page"},{"location":"operations/#Direct-Write","page":"Operations","title":"Direct Write","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"When direct_write is true, argument values are written directly into the query. The above example becomes","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"MyQuery{\n    arg1:\"word\"\n    arg2:[\n        123\n    ]\n    arg3:{\n        arg1:true\n        arg4:[\n            { arg10:1.0}\n            { arg10:2.0 }\n        ]\n    }\n}","category":"page"},{"location":"operations/#ENUMs","page":"Operations","title":"ENUMs","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"ENUM values are not quoted in GraphQL queries. If using direct_write=false, this is handled by the GraphQL server. However if using direct_write=true, arguments that are an ENUM value cannot be Strings in the argument dictionary. Instead, the string value should be wrapped in a GQLEnum type which will be written correctly.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"For example if the arguments are","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"args = Dict(\n    \"enum_arg\" => GQLEnum(\"value\")\n)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"The directly written query string will be","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"MyQuery{\n    enum_arg: value\n}","category":"page"},{"location":"operations/#Output-Fields","page":"Operations","title":"Output Fields","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The output fields are typically used to control what fields are in the response. The output_fields keyword argument can be any combination of strings, vectors and dictionaries and the query string is constructed accordingly. See below for some examples of output_fields values and the query string formed for a query called MyQuery with no arguments.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"# output_fields = \"Field1\"\nMyQuery{\n    Field1\n}","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"# output_fields = [\"Field1\", \"Field2\"]\nMyQuery{\n    Field1,\n    Field2\n}","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"# output_fields = [\"Field1\", \"Field2\", Dict(\"Field3\" => \"Field4\")]\nMyQuery{\n    Field1,\n    Field2,\n    Field3{\n        Field4\n    }\n}","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"If output_fields is not supplied for a query, introspection is used to query all possible fields (subject to some handling of recurive objects). If output_fields is not supplied for mutation or query, the query string has no output fields.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Output field names can be Aliases to control what the keys of the response object are.","category":"page"},{"location":"operations/#Aliases","page":"Operations","title":"Aliases","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"An alias can be created using a Alias struct","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"my_alias = Alias(\"my_name\", \"field_name\")","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Aliases will be correctly interpreted into the query string, for example the following aliases and query","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"alias1 = Alias(\"MyData\", \"MyQuery\")\noutput_alias = Alias(\"value\", \"Field1\")\nresponse = query(alias1, output_fields=output_alias)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"will produce the following query string","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"MyData: MyQuery{\n    value: Field1\n}","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"And the response will have the key \"MyData\" rather than \"MyQuery\" (see Response for more information).","category":"page"},{"location":"operations/#Response","page":"Operations","title":"Response","text":"","category":"section"},{"location":"operations/#errors_in_response","page":"Operations","title":"Errors","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"A GraphQL response can contain one or both of data and error fields, depending on what has happened during the execution of the operation. GraphQLClient, however, will always return a GQLResponse object that has both error and data fields. This is to ensure that operations are type stable. The table below shows what the value of the fields of a GQLResponse show about the response","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Outcome data key in response errors key in response GQLResponse.data GQLResponse.errors\nNo errors occurred Populated with requested data Not present Populated with requested data nothing\nError occurred before execution begins Not present Populated with error information nothing Populated with error information\nError occurred during execution null or relevant data entry is null Populated with error information nothing or relevant data entry is nothing Populated with error information","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"The key difference to be aware of is that if GQLReponse.data is nothing, this does not necessarily mean an error did or didn't occur during execution, just that an error occurred.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Whether or not GraphQLClient throws an exception when an error occurs during execution is controlled by the throw_on_execution_error keyword argument which defaults to false.","category":"page"},{"location":"operations/#custom_type_ref","page":"Operations","title":"Custom Types","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"By default, the response will be a GQLResponse{Any}. The parametric type refers to the value of the data field, which is a Dict{String, Union{Nothing, Any}}. query, mutate and open_subscription allow this parametric type to be set using the output_type positional argument, which typically enables more concrete typing. GraphQLClient uses JSON3 to deserialize the response.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"For example, if the response is","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"str = \"\"\"\n{\n    \"data\":{\n        \"MyQuery\": {\n            \"field1\": 1,\n            \"field2\": 2\n        }\n    }\n}\n\"\"\"","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Then the type Dict{String, Int} could be inputted to the output_type positional argument","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"DocTestSetup = quote\n    str = \"\"\"\n    {\n    \"data\": {\n        \"MyQuery\": {\n            \"field1\": 1,\n            \"field2\": 2\n            }\n        }\n    }\"\"\"\n    using JSON3, StructTypes\n    using GraphQLClient: GQLResponse\nend","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> JSON3.read(str, GQLResponse{Dict{String, Int}})\nGQLResponse{Dict{String, Int64}}\n  data: Dict{String, Union{Nothing, Dict{String, Int64}}}\n          MyQuery: Dict{String, Int64}","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Alternatively, a custom type can be defined and used with StructTypes allowing for more complex reponses.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> struct MyQuery\n           field1::Int\n           field2::Int\n       end\n\njulia> StructTypes.StructType(::Type{MyQuery}) = StructTypes.OrderedStruct()\n\njulia> JSON3.read(str, GQLResponse{MyQuery})\nGQLResponse{MyQuery}\n  data: Dict{String, Union{Nothing, MyQuery}}\n          MyQuery: MyQuery","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"DocTestSetup = nothing\nend","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"There are some things to watch out for when using a custom type, namely that a custom type will typically be less flexible than the default GQLResponse{Any} in terms of handling a response that is different to what is expected, and therefore deserialisation errors are more likley. If a custom type is used and deserialisation fails, GraphQLClient will attempt to deserialize with a GQLResponse{Any} to see if there are any error messages that were the source of the deserialisation failure. If this happens, the following warning will be outputted","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"┌ Warning: Deserialisation of GraphQL response failed, trying to access execution errors\n└ @ GraphQLClient ../GraphQLClient/src/http_execution.jl:144","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Followed by either a GraphQLError being thrown (if the response contained errors) or the following error message which will in turn be followed by the original deserialisation error message","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"┌ Error: No errors in GraphQL response, error most likely in deserialisation.\n│ Check type supplied to output_type.\n└ @ GraphQLClient ../GraphQLClient/src/http_execution.jl:150\nERROR: ArgumentError: invalid JSON at byte position ...","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"For more information, please see Struct Types Usage.","category":"page"},{"location":"operations/#HTTP-Interaction","page":"Operations","title":"HTTP Interaction","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"query and mutate make HTTP post requests to the GraphQL server. Retries and timeouts can be controlled using the following keyword arguments","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"retries - the number of times a query or mutation will be attempted before an error is thrown\nreadtimeout - the request timeout in seconds which should be set to 0 for no timeout","category":"page"},{"location":"operations/#Subscription-Control","page":"Operations","title":"Subscription Control","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"As well as the subscription_name, output_type, sub_args, output_fields and throw_on_execution_error arguments that have been discussed above, open_subscription has additional arguments which control initialisation and stopping of subscriptions.","category":"page"},{"location":"operations/#Initialisation","page":"Operations","title":"Initialisation","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"A function can be passed to the initfn to be run once the subscription is open. This means that if subscribing to the result of a mutation, for example, it can be guaranteed that no responses will be missed between the mutation being executed and the subscription being opened.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"If the retry keyword argument is true, GraphQLClient will retry the opening of the subscription if it fails. This keyword argument is passed directly to HTTP.WebSockets.open.","category":"page"},{"location":"operations/#Stopping","page":"Operations","title":"Stopping","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"A subscription stops in three situations","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"The function that acts on the response returning true\nIf the subtimeout keyword argument is greater than zero, the stopfn keyword argument is nothing and the subscription has been open for longer than subtimeout\nIf the subtimeout keyword argument is greater than zero, a function has been supplied to the stopfn keyword argument and this function returns true when executed (which occurs every subtimeout seconds)","category":"page"},{"location":"low_level_execution/#Low-Level-Execution","page":"Low Level Execution","title":"Low Level Execution","text":"","category":"section"},{"location":"low_level_execution/","page":"Low Level Execution","title":"Low Level Execution","text":"If required, it is possible to define operation strings manually and execute them using either a Client or a URL. The following code blocks shows  methods with which this can be performed.","category":"page"},{"location":"low_level_execution/","page":"Low Level Execution","title":"Low Level Execution","text":"HTTP retrying and server runtime execution handling are controlled by keyword arguments in the same was as query and mutate. See GraphQLClient.execute for further details.","category":"page"},{"location":"low_level_execution/#Using-a-URL-Directly","page":"Low Level Execution","title":"Using a URL Directly","text":"","category":"section"},{"location":"low_level_execution/","page":"Low Level Execution","title":"Low Level Execution","text":"These methods except the header keyword argument to set HTTP headers, with the Content-Type being set to \"application/json\" if none is supplied.","category":"page"},{"location":"low_level_execution/","page":"Low Level Execution","title":"Low Level Execution","text":"julia> # Using URL and query string\n\njulia> GraphQLClient.execute(\"https://countries.trevorblades.com\", \"query{country(code:\\\"BR\\\"){name}}\")\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n          country: Dict{String, Any}\n\njulia> # Using URL, query string and variables kwarg\n\njulia> variables = Dict(\"code\" => \"BR\");\n\njulia> GraphQLClient.execute(\"https://countries.trevorblades.com\", \"query(\\$code: ID!){country(code:\\$code){name}}\"; variables)\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n          country: Dict{String, Any}\n\njulia> # Using URL and supplying payload dictionary\n\njulia> payload = Dict(\"query\" => \"query(\\$code: ID!){country(code:\\$code){name}}\", \"variables\" => variables);\n\njulia> GraphQLClient.execute(\"https://countries.trevorblades.com\", payload)\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n          country: Dict{String, Any}\n","category":"page"},{"location":"low_level_execution/#Using-a-Client","page":"Low Level Execution","title":"Using a Client","text":"","category":"section"},{"location":"low_level_execution/","page":"Low Level Execution","title":"Low Level Execution","text":"These methods use Client.headers as the HTTP headers, with the Content-Type being set to \"application/json\" if none is supplied.","category":"page"},{"location":"low_level_execution/","page":"Low Level Execution","title":"Low Level Execution","text":"julia> client = Client(\"https://countries.trevorblades.com\");\n\njulia> GraphQLClient.execute(client, \"query{country(code:\\\"BR\\\"){name}}\")\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n          country: Dict{String, Any}\n\njulia> GraphQLClient.execute(client, \"query(\\$code: ID!){country(code:\\$code){name}}\"; variables)\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n          country: Dict{String, Any}\n\njulia> GraphQLClient.execute(client, payload)\nGraphQLClient.GQLResponse{Any}\n  data: Dict{String, Any}\n          country: Dict{String, Any}","category":"page"}]
}
