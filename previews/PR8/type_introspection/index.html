<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Type Introspection · GraphQLClient.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://deloittedigitalapac.github.io/GraphQLClient.jl/stable/type_introspection/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphQLClient.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../client/">Client</a></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><a class="tocitem" href="../struct_types_usage/">Struct Types Usage</a></li><li class="is-active"><a class="tocitem" href>Type Introspection</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Using-and-Initialising"><span>Using and Initialising</span></a></li><li><a class="tocitem" href="#Handling-Recursion-and-Nested-Objects"><span>Handling Recursion and Nested Objects</span></a></li><li><a class="tocitem" href="#forcing_re-introspection"><span>Forcing Re-Introspection</span></a></li><li><a class="tocitem" href="#Parent-Types"><span>Parent Types</span></a></li><li><a class="tocitem" href="#Custom-Scalar-Types"><span>Custom Scalar Types</span></a></li></ul></li><li><a class="tocitem" href="../low_level_execution/">Low Level Execution</a></li><li><a class="tocitem" href="../limitations/">Current Limitations</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public</a></li><li><a class="tocitem" href="../private/">Private</a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Type Introspection</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Type Introspection</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DeloitteDigitalAPAC/GraphQLClient.jl/blob/master/docs/src/type_introspection.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="type_introspection_page"><a class="docs-heading-anchor" href="#type_introspection_page">Type Introspection</a><a id="type_introspection_page-1"></a><a class="docs-heading-anchor-permalink" href="#type_introspection_page" title="Permalink"></a></h1><ul><li><a href="#type_introspection_page">Type Introspection</a></li><li class="no-marker"><ul><li><a href="#Overview">Overview</a></li><li><a href="#Using-and-Initialising">Using and Initialising</a></li><li><a href="#Handling-Recursion-and-Nested-Objects">Handling Recursion and Nested Objects</a></li><li><a href="#forcing_re-introspection">Forcing Re-Introspection</a></li><li><a href="#Parent-Types">Parent Types</a></li><li><a href="#Custom-Scalar-Types">Custom Scalar Types</a></li></ul></li></ul><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Because types are well defined in a GraphQL server and we can read the definition via introspection, we can build a Julia type for any GraphQL object.</p><pre><code class="language-julia-repl hljs">julia&gt; client = Client(&quot;https://countries.trevorblades.com&quot;)
GraphQLClient Client
       endpoint: https://countries.trevorblades.com
    ws_endpoint: wss://countries.trevorblades.com

julia&gt; T = introspect_object(client, &quot;Country&quot;)
GraphQLClient.var&quot;##Country#261&quot;</code></pre><p><a href="../public/#GraphQLClient.introspect_object"><code>introspect_object</code></a> creates a new, uniquely-named mutable type, which has a <a href="../struct_types_usage/#using_struct_types">StructType</a> of <code>Struct()</code> and where the type of every field is a <code>Union</code> of <code>Nothing</code> and the field type, . This makes the type flexible as it can be used for queries where not all field names are requested.</p><p>We can use this as the <code>output_type</code> of a query</p><pre><code class="language-julia-repl hljs">julia&gt; response = query(client, &quot;country&quot;, T, query_args=Dict(&quot;code&quot;=&gt;&quot;AU&quot;), output_fields=&quot;phone&quot;)
GraphQLClient.GQLResponse{GraphQLClient.var&quot;##Country#261&quot;}
  data: Dict{String, Union{Nothing, GraphQLClient.var&quot;##Country#261&quot;}}
          country: GraphQLClient.var&quot;##Country#261&quot;

julia&gt; country = response.data[&quot;country&quot;]
Country
  phone : 61

julia&gt; country.phone
&quot;61&quot;

julia&gt; isnothing(country.continent)
true

julia&gt; propertynames(country)
(:emoji, :currency, :states, :phone, :emojiU, :continent, :native, :capital, :name, :languages, :code)</code></pre><h2 id="Using-and-Initialising"><a class="docs-heading-anchor" href="#Using-and-Initialising">Using and Initialising</a><a id="Using-and-Initialising-1"></a><a class="docs-heading-anchor-permalink" href="#Using-and-Initialising" title="Permalink"></a></h2><p>The <code>Type</code> for an object can be accessed using <a href="../public/#GraphQLClient.get_introspected_type"><code>get_introspected_type</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; get_introspected_type(client, &quot;Country&quot;)
GraphQLClient.var&quot;##Country#262&quot;</code></pre><p>We can initialise an instance of the type with every field set to <code>nothing</code></p><pre><code class="language-julia-repl hljs">julia&gt; country = initialise_introspected_struct(client, &quot;Country&quot;)
Country
  All fields are nothing

julia&gt; country.name = &quot;Australia&quot;
&quot;Australia&quot;</code></pre><p>Or pass a dictionary of key value pairs to parameterise an instance of the type with</p><pre><code class="language-julia-repl hljs">julia&gt; fields = Dict(&quot;name&quot; =&gt; &quot;Australia&quot;, &quot;phone&quot; =&gt; &quot;61&quot;);

julia&gt; create_introspected_struct(client, &quot;Country&quot;, fields)
Country
   name : Australia
  phone : 61</code></pre><p>Note, the latter method will not work if the <code>mutable</code> keyword argument of <code>introspect_object</code> is set to <code>false</code>.</p><h2 id="Handling-Recursion-and-Nested-Objects"><a class="docs-heading-anchor" href="#Handling-Recursion-and-Nested-Objects">Handling Recursion and Nested Objects</a><a id="Handling-Recursion-and-Nested-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-Recursion-and-Nested-Objects" title="Permalink"></a></h2><p>GraphQL schemas can have objects as fields of other objects, and often these end up recursing. When an object is being introspected, any objects used in its fields are also introspected. For example, in the above introspection of <code>Country</code>, the object <code>State</code> is also introspected</p><pre><code class="language-julia-repl hljs">julia&gt; get_introspected_type(client, &quot;State&quot;)
GraphQLClient.var&quot;##State#259&quot;</code></pre><p>We can view all the introspected objects of a <code>Client</code> and see that four objects were actually introspected</p><pre><code class="language-julia-repl hljs">julia&gt; list_all_introspected_objects(client)
4-element Vector{String}:
 &quot;Continent&quot;
 &quot;State&quot;
 &quot;Country&quot;
 &quot;Language&quot;</code></pre><p>GraphQLClient keeps track of all introspected objects so that if two fields use the same object, they use the same Julia type. This information is stored in <code>client</code> so that if other objects are introspected that use already-introspected objects they will use the already-introspected types. Furthermore, if the name of an already-introspected object is inputted to <code>introspect_object</code>, the -already introspected type will be returned.</p><p>GraphQLClient also keeps track of the object(s) that is/are currently being introspected to  ensure that it doesn&#39;t attempt to introspect any of them again, which would lead to infinite recursion.</p><p>For example in the above introspection of <code>Country</code>, we actually get the following warning messages which were ommited above</p><pre><code class="language-julia-repl hljs">julia&gt; T = introspect_object(client, &quot;Country&quot;)
┌ Warning: Cannot introspect field country on type State due to recursion of object Country
└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:75
┌ Warning: Cannot introspect field countries on type Continent due to recursion of object Country
└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:75
GraphQLClient.var&quot;##Country#261&quot;</code></pre><p>They indicate that during the introspection of <code>Country</code>, both <code>State</code> and <code>Continent</code> are being introspected. Both of these objects have fields which use <code>Country</code>, and therefore GraphQLClient cannot introspect these fields, otherwise we would be using the type that we are currently in the process of definining which therefore doesn&#39;t exist (i.e., the definition of the type for <code>State</code> would fail as the type for <code>Country</code> doesn&#39;t exist yet).</p><p>The <code>allowed_level</code> keyword argument can be used to control how deep an object is introspected (note in this example we using the <code>force</code> keyword argument to <a href="#forcing_re-introspection">force the re-introspection</a> of the object)</p><pre><code class="language-julia-repl hljs">julia&gt; T = introspect_object(client, &quot;Country&quot;, allowed_level=1, force=true)
┌ Warning: Cannot introspect field languages on type Country due to allowed_level kwarg
└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:78
┌ Warning: Cannot introspect field states on type Country due to allowed_level kwarg
└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:78
┌ Warning: Cannot introspect field continent on type Country due to allowed_level kwarg
└ @ GraphQLClient ../GraphQLClient/src/type_construction.jl:78
GraphQLClient.var&quot;##Country#262&quot;</code></pre><p>When setting this to <code>1</code> in this example, <code>introspect_object</code> will not include any fields of <code>Country</code> that are objects</p><pre><code class="language-julia-repl hljs">julia&gt; fieldnames(T)
(:emoji, :currency, :native, :code, :name, :phone, :capital, :emojiU)</code></pre><p>Because of the nesting and recursion of objects, it is important to be careful with the order that objects are introspected and what level is allowed as this can affect the fields of introspected types. Considering <code>State</code> and <code>Country</code> in the above example, here are three possible outcomes:</p><p>If <code>allowed_level=3</code> and <code>Country</code> is introspected first (<code>State</code> is introspected during the introspection of <code>Country</code>)</p><pre><code class="language-julia hljs">julia&gt; Country = introspect_object(client, &quot;Country&quot;, allowed_level=3, force=true);

julia&gt; sort(collect(fieldnames(Country)))
11-element Vector{Symbol}:
 :capital
 :code
 :continent
 :currency
 :emoji
 :emojiU
 :languages
 :name
 :native
 :phone
 :states

julia&gt; sort(collect(fieldnames(get_introspected_type(client, &quot;State&quot;))))
2-element Vector{Symbol}:
 :code
 :name</code></pre><p>If <code>allowed_level=3</code> and State is introspected first (<code>Client</code> is introspected during the introspection of <code>Country</code>) we can see that <code>State</code> now has the field <code>name</code> and <code>Country</code> does not have the field <code>states</code>.</p><pre><code class="language-julia hljs">julia&gt; State = introspect_object(client, &quot;State&quot;, allowed_level=3, force=true);

julia&gt; sort(collect(fieldnames(State)))
3-element Vector{Symbol}:
 :code
 :country
 :name

julia&gt; sort(collect(fieldnames(get_introspected_type(client, &quot;Country&quot;))))
10-element Vector{Symbol}:
 :capital
 :code
 :continent
 :currency
 :emoji
 :emojiU
 :languages
 :name
 :native
 :phone</code></pre><p>If <code>allowed_level=1</code>, both objects must be introspected separately and have fewer fields</p><pre><code class="language-julia hljs">julia&gt; State = introspect_object(client, &quot;State&quot;, allowed_level=1, force=true);

julia&gt; sort(collect(fieldnames(State)))
2-element Vector{Symbol}:
 :code
 :name

julia&gt; Country = introspect_object(client, &quot;Country&quot;, allowed_level=1, force=true);

julia&gt; sort(collect(fieldnames(Country)))
10-element Vector{Symbol}:
 :capital
 :code
 :currency
 :emoji
 :emojiU
 :name
 :native
 :phone</code></pre><p>We can see that in each of the three scenarios, the types have different fields according to how they have been introspected.</p><p>A more sophiscated solution could potentially use parametric typing to get around this and allow full recursion within defined types, but this is not implemented currently.</p><h2 id="forcing_re-introspection"><a class="docs-heading-anchor" href="#forcing_re-introspection">Forcing Re-Introspection</a><a id="forcing_re-introspection-1"></a><a class="docs-heading-anchor-permalink" href="#forcing_re-introspection" title="Permalink"></a></h2><p>Fortunately, GraphQL schemas are typically fairly static so we shouldn&#39;t need to re-introspect an object too frequently. Howeve re-intropsection of an object and any objects used by its fields (and so on for those objects) can be forced using the <code>force</code> keyword argument. This should be done with care, however, as the following example illustrates.</p><p>First we introspect <code>Country</code>, as we have done previously</p><pre><code class="language-julia-repl hljs">julia&gt; Country = introspect_object(client, &quot;Country&quot;)
GraphQLClient.var&quot;##Country#403&quot;</code></pre><p>Then we force re-introspect <code>Language</code>, which has already been introspected during the intropsection of <code>Country</code></p><pre><code class="language-julia-repl hljs">julia&gt; Language = introspect_object(client, &quot;Language&quot;, force=true)
GraphQLClient.var&quot;##Language#404&quot;</code></pre><p>Now if we try to use them together, the type of <code>Language</code> will not match that of the <code>languages</code> field of <code>Country</code></p><pre><code class="language-julia-repl hljs">julia&gt; language = create_introspected_struct(client, &quot;Language&quot;, Dict(&quot;name&quot; =&gt; &quot;English&quot;))
Language
  name : English

julia&gt; country = create_introspected_struct(client, &quot;Country&quot;, Dict(&quot;languages&quot; =&gt; [language]))
ERROR: MethodError: Cannot `convert` an object of type GraphQLClient.var&quot;##Language#404&quot; to an object of type GraphQLClient.var&quot;##Language#400&quot;</code></pre><p>It is safer to use the <code>reset_all</code> keyword argument once to delete all introspected types and start again.</p><pre><code class="language-julia-repl hljs">julia&gt; Language = introspect_object(client, &quot;Language&quot;, reset_all=true);

julia&gt; Country = introspect_object(client, &quot;Country&quot;);

julia&gt; language = create_introspected_struct(client, &quot;Language&quot;, Dict(&quot;name&quot; =&gt; &quot;English&quot;))
Language
  name : English

julia&gt; country = create_introspected_struct(client, &quot;Country&quot;, Dict(&quot;languages&quot; =&gt; [language]))
Country
  languages : GraphQLClient.var&quot;##Language#405&quot;[GraphQLClient.var&quot;##Language#405&quot;(nothing, nothing, nothing, &quot;English&quot;)]</code></pre><h2 id="Parent-Types"><a class="docs-heading-anchor" href="#Parent-Types">Parent Types</a><a id="Parent-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-Types" title="Permalink"></a></h2><p>By default, all introspected types have the parent type <a href="../public/#GraphQLClient.AbstractIntrospectedStruct"><code>GraphQLClient.AbstractIntrospectedStruct</code></a>, which has a defined <a href="../struct_types_usage/#using_struct_types">StructType</a> of <code>Struct</code>. However it may be desirable to change this for multiple dispatch or display purposes. This can be done in two ways in two ways.</p><p>The <code>parent_type</code> keyword argument sets the parent type of the top level object being introspected, but no nested objects.</p><pre><code class="language-julia-repl hljs">julia&gt; abstract type MyType end

julia&gt; Country = introspect_object(client, &quot;Country&quot;, parent_type=MyType, force=true);

julia&gt;  Country &lt;: MyType
true

julia&gt; get_introspected_type(client, &quot;State&quot;) &lt;: MyType
false</code></pre><p>Alternatively, a dictionary mapping object name to parent type can be supplied to the <code>parent_map</code> keyword argument. Any object that is not in the map will have the default parent type.</p><pre><code class="language-julia-repl hljs">julia&gt; parent_map = Dict(&quot;Country&quot; =&gt; MyType, &quot;State&quot; =&gt; MyType)
julia&gt; Country = introspect_object(client, &quot;Country&quot;, parent_map=parent_map, force=true);

julia&gt; Country &lt;: MyType
true

julia&gt; get_introspected_type(client, &quot;State&quot;) &lt;: MyType
true

julia&gt; get_introspected_type(client, &quot;Continent&quot;) &lt;: MyType # not in parent_map
false</code></pre><p>If both <code>parent_type</code> and <code>parent_map</code> are supplied, <code>parent_type</code> take precedence.</p><h2 id="Custom-Scalar-Types"><a class="docs-heading-anchor" href="#Custom-Scalar-Types">Custom Scalar Types</a><a id="Custom-Scalar-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Scalar-Types" title="Permalink"></a></h2><p>If the GraphQL server has custom scalar types defined and these are used by the object(s) being intropsected, then they must be mapped to Julia types in the <code>custom_scalar_types</code> keyword argument of <code>introspect_object</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; custom_scalar_types = Dict(&quot;ScalarTypeName&quot; =&gt; Int8)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../struct_types_usage/">« Struct Types Usage</a><a class="docs-footer-nextpage" href="../low_level_execution/">Low Level Execution »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 1 November 2021 19:11">Monday 1 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
